// CVE and vulnerability data service
import type { ClNode, GraphPayload } from './types';

export interface CVEInfo {
  id: string; // CVE-YYYY-NNNNN
  summary: string;
  cvssScore?: number;
  cvssVector?: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  published: string; // ISO date
  lastModified: string; // ISO date
  references: string[];
  affectedProducts: string[];
  exploitAvailable?: boolean;
  patchAvailable?: boolean;
  ageInDays: number;
  urgencyScore: number; // 0-100 based on CVSS, exploit availability, age
}

export interface PackageVulnerability {
  packageName: string;
  packageVersion?: string;
  vulnerabilities: CVEInfo[];
  riskScore: number; // Aggregate risk for this package
}

export interface VulnerabilityAssessment {
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  packagesWithVulns: PackageVulnerability[];
  overallRiskScore: number;
  recommendedActions: string[];
}

// Mock CVE database - In a real implementation, this would connect to NVD API, OSV, GitHub Security, etc.
const MOCK_CVE_DATABASE: Record<string, CVEInfo[]> = {
  // Example vulnerabilities for common packages
  'openssl': [
    {
      id: 'CVE-2024-0001',
      summary: 'Buffer overflow in OpenSSL certificate parsing could allow remote code execution',
      cvssScore: 9.8,
      cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
      severity: 'CRITICAL',
      published: '2024-01-15T10:00:00Z',
      lastModified: '2024-01-20T15:30:00Z',
      references: [
        'https://www.openssl.org/news/secadv/20240115.txt',
        'https://nvd.nist.gov/vuln/detail/CVE-2024-0001'
      ],
      affectedProducts: ['openssl < 3.0.13', 'openssl < 1.1.1x'],
      exploitAvailable: true,
      patchAvailable: true,
      ageInDays: 30,
      urgencyScore: 95
    }
  ],
  'curl': [
    {
      id: 'CVE-2023-5678',
      summary: 'Information disclosure in curl URL parsing',
      cvssScore: 5.3,
      severity: 'MEDIUM',
      published: '2023-12-01T08:00:00Z',
      lastModified: '2023-12-05T12:00:00Z',
      references: ['https://curl.se/docs/security.html'],
      affectedProducts: ['curl < 8.5.0'],
      exploitAvailable: false,
      patchAvailable: true,
      ageInDays: 60,
      urgencyScore: 40
    }
  ],
  'nginx': [
    {
      id: 'CVE-2023-9999',
      summary: 'Denial of service vulnerability in nginx request processing',
      cvssScore: 7.5,
      severity: 'HIGH',
      published: '2023-11-10T14:00:00Z',
      lastModified: '2023-11-15T09:30:00Z',
      references: ['http://nginx.org/en/security_advisories.html'],
      affectedProducts: ['nginx < 1.24.1'],
      exploitAvailable: false,
      patchAvailable: true,
      ageInDays: 90,
      urgencyScore: 65
    }
  ]
};

/**
 * Extract package information from SBOM data
 */
function extractPackagesFromSBOM(sbomData: any): Array<{name: string, version?: string, purl?: string}> {
  const packages: Array<{name: string, version?: string, purl?: string}> = [];
  
  if (!sbomData?.packages) {
    return packages;
  }

  for (const pkg of sbomData.packages) {
    if (pkg.name && pkg.name !== 'DOCUMENT') {
      packages.push({
        name: pkg.name,
        version: pkg.versionInfo,
        purl: pkg.externalRefs?.find((ref: any) => ref.referenceType === 'purl')?.referenceLocator
      });
    }
  }

  return packages;
}

/**
 * Get vulnerabilities for a specific package
 */
export async function getPackageVulnerabilities(packageName: string, version?: string): Promise<CVEInfo[]> {
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 100));
  
  // Simple name matching for mock data
  const normalizedName = packageName.toLowerCase();
  
  for (const [mockPackage, vulns] of Object.entries(MOCK_CVE_DATABASE)) {
    if (normalizedName.includes(mockPackage)) {
      return vulns.map(vuln => ({
        ...vuln,
        ageInDays: Math.floor((Date.now() - new Date(vuln.published).getTime()) / (1000 * 60 * 60 * 24))
      }));
    }
  }
  
  return [];
}

/**
 * Calculate urgency score based on CVSS, exploit availability, age
 */
function calculateUrgencyScore(cve: CVEInfo): number {
  let score = 0;
  
  // Base score from CVSS
  if (cve.cvssScore) {
    score = cve.cvssScore * 10; // Scale to 0-100
  } else {
    // Fallback based on severity
    const severityScores = { LOW: 25, MEDIUM: 50, HIGH: 75, CRITICAL: 90 };
    score = severityScores[cve.severity];
  }
  
  // Exploit availability adds urgency
  if (cve.exploitAvailable) {
    score = Math.min(100, score + 20);
  }
  
  // Age factor - newer vulnerabilities are more urgent
  if (cve.ageInDays < 7) {
    score = Math.min(100, score + 15); // Very recent
  } else if (cve.ageInDays < 30) {
    score = Math.min(100, score + 10); // Recent
  } else if (cve.ageInDays > 365) {
    score = Math.max(10, score - 20); // Old vulnerabilities less urgent
  }
  
  return Math.round(score);
}

/**
 * Assess vulnerabilities for the entire graph
 */
export async function assessGraphVulnerabilities(data: GraphPayload): Promise<VulnerabilityAssessment> {
  const packagesWithVulns: PackageVulnerability[] = [];
  let totalVulns = 0;
  let criticalCount = 0;
  let highCount = 0;
  let mediumCount = 0;
  let lowCount = 0;
  
  // Find SBOM nodes and extract packages
  const sbomNodes = data.nodes.filter(node => node.type === 'SBOM_JSON');
  
  for (const sbomNode of sbomNodes) {
    if (!sbomNode.meta) continue;
    
    const packages = extractPackagesFromSBOM(sbomNode.meta);
    
    for (const pkg of packages) {
      const vulnerabilities = await getPackageVulnerabilities(pkg.name, pkg.version);
      
      if (vulnerabilities.length > 0) {
        // Calculate urgency scores
        const vulnsWithUrgency = vulnerabilities.map(vuln => ({
          ...vuln,
          urgencyScore: calculateUrgencyScore(vuln)
        }));
        
        // Count by severity
        for (const vuln of vulnsWithUrgency) {
          totalVulns++;
          switch (vuln.severity) {
            case 'CRITICAL': criticalCount++; break;
            case 'HIGH': highCount++; break;
            case 'MEDIUM': mediumCount++; break;
            case 'LOW': lowCount++; break;
          }
        }
        
        // Calculate package risk score (average of vulnerability urgency scores)
        const riskScore = Math.round(
          vulnsWithUrgency.reduce((sum, vuln) => sum + vuln.urgencyScore, 0) / vulnsWithUrgency.length
        );
        
        packagesWithVulns.push({
          packageName: pkg.name,
          packageVersion: pkg.version,
          vulnerabilities: vulnsWithUrgency,
          riskScore
        });
      }
    }
  }
  
  // Calculate overall risk score
  const overallRiskScore = packagesWithVulns.length > 0 
    ? Math.round(packagesWithVulns.reduce((sum, pkg) => sum + pkg.riskScore, 0) / packagesWithVulns.length)
    : 0;
  
  // Generate recommendations
  const recommendedActions = generateVulnerabilityRecommendations({
    totalVulnerabilities: totalVulns,
    criticalCount,
    highCount,
    mediumCount,
    lowCount,
    packagesWithVulns,
    overallRiskScore,
    recommendedActions: []
  });
  
  return {
    totalVulnerabilities: totalVulns,
    criticalCount,
    highCount,
    mediumCount,
    lowCount,
    packagesWithVulns,
    overallRiskScore,
    recommendedActions
  };
}

/**
 * Generate actionable recommendations based on vulnerability assessment
 */
function generateVulnerabilityRecommendations(assessment: VulnerabilityAssessment): string[] {
  const recommendations: string[] = [];
  
  if (assessment.criticalCount > 0) {
    recommendations.push(`🚨 URGENT: Address ${assessment.criticalCount} critical vulnerabilities immediately`);
    recommendations.push('Critical vulnerabilities can be exploited to gain full system control');
  }
  
  if (assessment.highCount > 0) {
    recommendations.push(`⚠️ HIGH PRIORITY: Fix ${assessment.highCount} high-severity vulnerabilities`);
    recommendations.push('Schedule patching within 7-14 days for high-severity issues');
  }
  
  if (assessment.mediumCount > 5) {
    recommendations.push(`📋 MODERATE: Plan remediation for ${assessment.mediumCount} medium-severity vulnerabilities`);
  }
  
  // Package-specific recommendations
  const highRiskPackages = assessment.packagesWithVulns.filter(pkg => pkg.riskScore > 70);
  if (highRiskPackages.length > 0) {
    recommendations.push(`🔄 UPDATE: Prioritize updating ${highRiskPackages.map(p => p.packageName).join(', ')}`);
  }
  
  // Exploit-based recommendations
  const exploitableVulns = assessment.packagesWithVulns
    .flatMap(pkg => pkg.vulnerabilities)
    .filter(vuln => vuln.exploitAvailable);
    
  if (exploitableVulns.length > 0) {
    recommendations.push(`💥 EXPLOIT RISK: ${exploitableVulns.length} vulnerabilities have known exploits`);
  }
  
  if (assessment.totalVulnerabilities === 0) {
    recommendations.push('✅ No known vulnerabilities found in scanned packages');
    recommendations.push('Continue monitoring for new security advisories');
  }
  
  return recommendations;
}

/**
 * Get CVSS severity color for UI display
 */
export function getCVSSSeverityStyle(severity: string) {
  const styles = {
    CRITICAL: { color: '#dc2626', bgColor: '#fee2e2', textColor: '#991b1b' },
    HIGH: { color: '#ea580c', bgColor: '#fed7aa', textColor: '#c2410c' },
    MEDIUM: { color: '#d97706', bgColor: '#fef3c7', textColor: '#92400e' },
    LOW: { color: '#059669', bgColor: '#d1fae5', textColor: '#065f46' }
  };
  
  return styles[severity as keyof typeof styles] || styles.MEDIUM;
}

/**
 * Format CVSS score for display
 */
export function formatCVSSScore(score?: number): string {
  if (!score) return 'N/A';
  
  if (score >= 9.0) return `${score.toFixed(1)} (Critical)`;
  if (score >= 7.0) return `${score.toFixed(1)} (High)`;
  if (score >= 4.0) return `${score.toFixed(1)} (Medium)`;
  return `${score.toFixed(1)} (Low)`;
}

/**
 * Get days since publication in human readable format
 */
export function getVulnerabilityAge(ageInDays: number): string {
  if (ageInDays < 1) return 'Today';
  if (ageInDays === 1) return '1 day ago';
  if (ageInDays < 7) return `${ageInDays} days ago`;
  if (ageInDays < 30) return `${Math.round(ageInDays / 7)} weeks ago`;
  if (ageInDays < 365) return `${Math.round(ageInDays / 30)} months ago`;
  return `${Math.round(ageInDays / 365)} years ago`;
}
